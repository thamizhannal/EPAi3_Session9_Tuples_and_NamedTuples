# -*- coding: utf-8 -*-
"""epai3_assignment9.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1loKjFw-Dulb-SYimJ4sXNX2cXiDjv4QH

# NamedTuple: fake profile data processing
Use the Faker (Links to an external site.)library to get 10000 random profiles. **Using namedtuple**, calculate the largest blood type, mean-current_location, oldest_person_age, and average age (add proper doc-strings).
"""

# Install Faker library
# !pip install Faker

# import faker library
from faker import Faker

from collections import namedtuple
from datetime import date, datetime

# calculate the largest blood type
from collections import Counter
# mean-current_location
import math


# Initialize Faker library
fake = Faker()
profile = fake.profile()


# NamedTuples
def create_fake_profile_namedtuple(num: int):
    """
    Create fake profile from faker library and pack it in a namedtuples for data processing
    @param: number of profiles needs to be generated from faker library.
    @return: return all profiles into a named tuple.
    """

    # 'Profile', 'address, birthdate, blood_group, company, current_location, job, mail, name, residence, sex, ssn, username, website ')
    profile = namedtuple('Profile', sorted(fake.profile().keys()))

    # Named Tuple Holder for Profile
    profiles = namedtuple('profiles', ['Profile'])

    person_profile = profile(**fake.profile())

    # create all_profiles and add pack all profiles in all_profiles
    all_profiles = profiles(person_profile)

    for _ in range(num):
        person_profile = profile(**fake.profile())
        all_profiles += profiles(person_profile)
    return all_profiles

#all_profiles = create_fake_profile_namedtuple(10)


def calc_largest_blood_type_namedtuple(all_profiles: namedtuple):
    """
    computes the largest blodd group type from blood group of a person
    @params: all_profiles named tuple
    @return: largest blood group type as string
    """

    """
    Counter: Make use of Python Counter which returns count of each element in the list. 
    Thus, we simply find the most common element by using most_common() method.
  
    """
    start = datetime.now()
    largest_blood_type = Counter(list(map(lambda v: v.blood_group, all_profiles))).most_common(1)[0][0]
    end = datetime.now()

    return (end-start), largest_blood_type


#calc_largest_blood_type_namedtuple(all_profiles)


def calc_mean_curr_loc_namedtuple(all_profiles: namedtuple):
    """
    computes mean current location from location value of a person
    @params: all_profiles named tuple
    @return: x,y axis location as Decimal value

    """

    '''
    map() function returns a map object(which is an iterator) of the results after
    applying the given function to each item of a given iterable (list, tuple etc.)
    e.x
    numbers = (1, 2, 3, 4)
    result = map(lambda x: x + x, numbers)
    '''
    start = datetime.now()
    num_of_profiles = len(all_profiles)
    curr_locations = (list(map(lambda v: v.current_location, all_profiles)))
    x = round(sum(map(lambda loc: loc[0], curr_locations)) / num_of_profiles, 7)
    y = round(sum(map(lambda loc: loc[1], curr_locations)) / num_of_profiles, 7)
    end = datetime.now()

    return (end-start), x, y


#calc_mean_curr_loc_namedtuple(all_profiles)


def calculate_age(birth: datetime):
    """
    Calculate age from birth year, month and day.
    @param: birth date as datetime
    @return age as int
    """
    today = date.today()
    return today.year - birth.year - ((today.month, today.day) < (birth.month, birth.day))


#  oldest_person_age
def oldest_person_age_namedtuple(all_profiles: namedtuple):
    """
    Calculats age from birthdate and calulate olderst age of the person
    @params: all_profiles named tuple
    @return: oldest age as int value
    """
    start = datetime.now()
    oldest_age = max(map(lambda v: calculate_age(v.birthdate), all_profiles))
    end = datetime.now()

    return end-start, oldest_age


#oldest_person_age_namedtuple(all_profiles)


def calc_avg_person_age_namedtuple(all_profiles: namedtuple):
    """
    Calculats age from birthdate and compute average age of a person.
    @params: all_profiles named tuple
    @return: avg age as int value
    """
    start = datetime.now()

    try:
        avg_age = round(sum(map(lambda v: calculate_age(v.birthdate), all_profiles)) / len(all_profiles), 1)
    except ValueError as ve:
        print(("Error in computing age from birthdate "))
        print(ve.trace())
    end = datetime.now()

    return (end-start), avg_age


#calc_avg_person_age__namedtuple(all_profiles)


def comp_elasped_time_namedtuple_process():
    start_time = datetime.now()
    num_of_profiles = 10000

    profiles_dict = create_fake_profile_namedtuple(num_of_profiles)

    oldest_person_age_namedtuple(profiles_dict)
    calc_largest_blood_type_namedtuple(profiles_dict)
    calc_mean_curr_loc_namedtuple(profiles_dict)
    calc_avg_person_age_namedtuple(profiles_dict)

    end_time = datetime.now()
    elasped_time = end_time - start_time
    print(f'NamedTuples of {num_of_profiles} faker profiles tooks hh:mm:ss.ms {elasped_time} for processing! ')


#comp_elasped_time_namedtuple_process()

"""### **NamedTuples of 10000 faker profiles tooks hh:mm:ss.ms 0:00:13.575570 for processing!** 


```
# This is formatted as code
```

# Dictionary: fake_profile data processing
Use the Faker (Links to an external site.)library to get 10000 random profiles. **Using dictionary**, calculate the largest blood type, mean-current_location, oldest_person_age, and average age (add proper doc-strings).
"""


def create_fake_profile_dict(num_of_profiles: int):
    """
    Create fake profile from faker library and pack it in a namedtuples for data processing
    @param: number of profiles needs to be generated from faker library.
    @return: return all profiles into a dict.
    """
    profiles = {}
    for index in range(num_of_profiles):
        profiles[index] = fake.profile()
        # print(profiles[index])
        index += 1
    return profiles


#profiles_dict = create_fake_profile_dict(5)


def oldest_person_age_dict(profiles_dict: dict):
    """
    Calculats age from birthdate of the profiles and calulate olderst age of the person
    @params: profiles as dictionary
    @return: oldest age as int value

    """

    profile = min(profiles_dict.values(), key=lambda v: (v['birthdate']))
    age = calculate_age(profile['birthdate'])
    return age


#oldest_person_age_dict(profiles_dict)


#  calculate the largest blood type
def calc_largest_blood_type_dict(profiles_dict: dict):
    """
    computes the largest blood group type from blood group of a person's profile dictionary
    @params: profiles as dictionary
    @return: largest blood group type as string
    """
    start = datetime.now()

    largest_blood_group = max(list(map(lambda v: (v['blood_group']), profiles_dict.values())))
    end = datetime.now()

    return (end-start), largest_blood_group


#calc_largest_blood_type_dict(profiles_dict)


# mean-current_location
def calc_mean_curr_loc_dict(profiles_dict: dict):
    """
    computes mean current location from location value of a person stored in dictionary
    @params: profiles as dictionary
    @return: x,y axis location as Decimal value
    """
    start = datetime.now()

    num_of_profiles = len(profiles_dict)
    curr_locations = list(map(lambda v: v['current_location'], profiles_dict.values()))
    # print(curr_locations)
    x = round(sum(map(lambda loc: loc[0], curr_locations)) / num_of_profiles, 7)
    y = round(sum(map(lambda loc: loc[1], curr_locations)) / num_of_profiles, 7)
    end = datetime.now()

    return (end-start), x, y


#calc_mean_curr_loc_dict(profiles_dict)


def oldest_person_age_dict(profiles_dict: dict):
    """
    Calculats age from birthdate and calulate olderst age of the person from profiles dictionary
    @params: profiles as dictionary
    @return: oldest age as int value
    """
    start = datetime.now()

    profile = min(profiles_dict.values(), key=lambda v: (v['birthdate']))
    age = calculate_age(profile['birthdate'])
    end = datetime.now()

    return (end-start), age


#oldest_person_age_dict(profiles_dict)


def avg_person_age_dict(profiles_dict: dict):
    """
    Calculats age from birthdate and compute average age of a person from profiles dictionary
    @params: profiles as dictionary
    @return: avg age as int value
    """
    start = datetime.now()
    avg_age = sum(list(map(lambda v: calculate_age(v['birthdate']), profiles_dict.values()))) / len(profiles_dict)
    end = datetime.now()
    return (end-start), avg_age


#avg_person_age_dict(profiles_dict)


def comp_elasped_time_dict_process():
    start_time = datetime.now()
    num_of_profiles = 10000
    profiles_dict = create_fake_profile_dict(num_of_profiles)
    oldest_person_age_dict(profiles_dict)
    calc_largest_blood_type_dict(profiles_dict)
    calc_mean_curr_loc_dict(profiles_dict)
    avg_person_age_dict(profiles_dict)
    end_time = datetime.now()
    elasped_time = end_time - start_time
    print(f'Dictionay of {num_of_profiles} faker profiles tooks hh:mm:ss.ms {elasped_time} for processing! ')


#comp_elasped_time_dict_process()

"""### Dictionay of 10000 faker profiles tooks hh:mm:ss.ms 0:00:15.324825 for processing!

# Named Tupes >>> Dictionary
### **NamedTuples of 10000 faker profiles tooks hh:mm:ss.ms 0:00:13.575570 for processing!** 
### **Dictionay of 10000 faker profiles tooks hh:mm:ss.ms 0:00:15.493149 for processing!**
### **NamedTuple** > **Dictionary** for large scale data processing"

#Stock Exchange
Create fake data (you can use Faker for company names) for imaginary stock exchange for top 100 companies (name, symbol, open, high, close). Assign a random weight to all the companies. Calculate and show what value the stock market started at, what was the highest value during the day, and where did it end. Make sure your open, high, close are not totally random. You can only use namedtuple. - 500  (including 10 test cases)
"""


from random import uniform, randint, sample
import math


# Global variables
# To Hold Company in stock exchange
Company = namedtuple('Company', 'name, symbol, open, high, low, close')
# To hold all companies in stock exchange
all_companies = namedtuple('all_companies', ['Company'])
# Holder for random weights
random_weight = namedtuple('random_weight', 'weight')


def init_stock_exchange(num_of_stocks: int):
    """
    This function creates a named tuples to hold the Company that consist of name, symbol, open, high, low, close
    It initialized weight of each stocks randomly. From random weight a normalized weigh is being computed
    that represents % of weight of each stock in exchange.
    @param: num_of_stocks present in the exchange as int value
    @return: all_stocks that initialize with Company and normalized weight for num_of_stocks
    """

    weight = round(uniform(0, 1), 2)
    total_random_weights = random_weight(weight)

    for _ in range(num_of_stocks):
        weight = round(uniform(0, 1), 2)
        total_random_weights += weight,

    """
    Convert Random weight into normalized weights to assign price to stocks
    Normalized weight represents % of weigh a stock holds in exchange value
    """
    normalized_weights = tuple(map(lambda x: (x / sum(total_random_weights) * 100), total_random_weights))
    for n in normalized_weights:
        print("Normalized weights:", round(n, 2))

    # Assign price to stocks using normalized weights
    open = round(normalized_weights[_] * randint(1, 100), 2)

    """ 
    Assumption: Stocks can't go higher than +20% in a day
    Assumption: Stock can't go lower than -20% in a day
    """
    high = round(open * uniform(1.0, 1.2), 2)
    low = round(open * uniform(0.8, 1.0), 2)
    close = round(open * uniform(0.8, 1.2), 2)
    company = fake.company()
    # symbol is first 4 alphabets of the company name.
    symbol = company[:4].upper()
    """
    close is high, then mark high=close
    """
    if close > high:
        high = close
    """
    Open price can he highest price of the stock in a day 
    """
    if high <= open:
        high = open

    c = Company(company, symbol, open, high, low, close)
    all_stocks = all_companies(c)

    return all_stocks, normalized_weights


#init_stock_exchange(5)


def run_stock_exchange(all_stocks: namedtuple, normalized_weights: namedtuple, num_of_stocks: int):
    """
    @param: all_stocks named tuple is initialized with Company class
    @param: normalized_weight is percentage of weight each stock holds in stock exchange
    @param: num_of_stocks is int represents number of stocks in exchange
    @return list of companies as named tuple thaat consist of stocks name, symbol, open, high, low and close prices
    """

    for _ in range(num_of_stocks - 1):
        # Assign price to stocks using normalized weights
        print(normalized_weights[_])
        open = round(normalized_weights[_] * randint(1, 100), 2)

        """ 
        Assumption: Stocks can't go higher than +20% in a day
        Assumption: Stock can't go lower than -20% in a day
    
        """
        high = round(open * uniform(1.0, 1.2), 2)
        low = round(open * uniform(0.8, 1.0), 2)
        close = round(open * uniform(0.8, 1.2), 2)
        company = fake.company()
        symbol = company[:4].upper()
        """
        close is high, then mark high=close
    
        """
        if close > high:
            high = close
        """
        Open price can he highest price of the stock in a day 
        """
        if high <= open:
            high = open

        c = Company(company, symbol, open, high, low, close)
        all_stocks += all_companies(c)

    return all_stocks


#all_stocks, normalized_weights = init_stock_exchange(100)
#run_stock_exchange(all_stocks, normalized_weights, 100)

